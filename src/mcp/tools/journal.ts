import {
  CreateJournalEntryRequestSchema,
  CreateCampaignNoteRequestSchema,
  JournalSearchRequestSchema,
  JournalEntrySchema,
  CampaignNoteSchema,
} from '../../schemas';
import type { Env } from '../../index';
import { ZodError } from 'zod';
import { v4 as uuidv4 } from 'uuid';

export async function journalAddEntryHandler(c: any) {
  try {
    const body = await c.req.json();
    const input = CreateJournalEntryRequestSchema.parse(body);

    const entryId = uuidv4();
    const now = new Date().toISOString();

    const journalEntry = {
      id: entryId,
      sessionId: input.sessionId,
      entryType: input.entryType,
      title: input.title,
      content: input.content,
      timestamp: now,
      actorId: input.actorId,
      location: input.location,
      tags: input.tags || [],
      metadata: input.metadata || {},
    };

    // Store in database
    await c.env.DB.prepare(
      `
      INSERT INTO journal_entries (id, sessionId, entryType, title, content, timestamp, actorId, location, tags, metadata)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `,
    )
      .bind(
        journalEntry.id,
        journalEntry.sessionId,
        journalEntry.entryType,
        journalEntry.title,
        journalEntry.content,
        journalEntry.timestamp,
        journalEntry.actorId,
        journalEntry.location,
        JSON.stringify(journalEntry.tags),
        JSON.stringify(journalEntry.metadata),
      )
      .run();

    // Log the journal entry creation
    await logAction(c.env, {
      sessionId: input.sessionId,
      actorId: input.actorId,
      kind: 'journal',
      payload: { action: 'create_entry', entryId, entryType: input.entryType },
      by: 'system',
      autoGenerated: false,
    });

    return c.json({
      success: true,
      data: journalEntry,
      serverTs: now,
    });
  } catch (error) {
    console.error('Journal add entry error:', error);
    if (error instanceof ZodError) {
      return c.json(
        {
          success: false,
          error: JSON.stringify(error.issues),
        },
        400,
      );
    }
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      500,
    );
  }
}

export async function journalGetEntriesHandler(c: any) {
  try {
    const sessionId = c.req.param('sessionId');
    const entryType = c.req.query('entryType');
    const actorId = c.req.query('actorId');
    const limit = parseInt(c.req.query('limit') || '50');
    const offset = parseInt(c.req.query('offset') || '0');

    if (!sessionId) {
      return c.json(
        {
          success: false,
          error: 'sessionId parameter required',
        },
        400,
      );
    }

    let query = 'SELECT * FROM journal_entries WHERE sessionId = ?';
    const params: any[] = [sessionId];

    if (entryType) {
      query += ' AND entryType = ?';
      params.push(entryType);
    }

    if (actorId) {
      query += ' AND actorId = ?';
      params.push(actorId);
    }

    query += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';
    params.push(limit, offset);

    const result = await c.env.DB.prepare(query)
      .bind(...params)
      .all();

    // Parse JSON fields
    const entries = result.results.map((entry: any) => ({
      ...entry,
      tags: JSON.parse(entry.tags || '[]'),
      metadata: JSON.parse(entry.metadata || '{}'),
    }));

    return c.json({
      success: true,
      data: entries,
      serverTs: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Journal get entries error:', error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      500,
    );
  }
}

export async function journalAddCampaignNoteHandler(c: any) {
  try {
    const body = await c.req.json();
    const input = CreateCampaignNoteRequestSchema.parse(body);

    const noteId = uuidv4();
    const now = new Date().toISOString();

    const campaignNote = {
      id: noteId,
      sessionId: input.sessionId,
      category: input.category,
      title: input.title,
      content: input.content,
      timestamp: now,
      metadata: input.metadata || {},
    };

    // Store in database
    await c.env.DB.prepare(
      `
      INSERT INTO campaign_notes (id, sessionId, category, title, content, timestamp, metadata)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `,
    )
      .bind(
        campaignNote.id,
        campaignNote.sessionId,
        campaignNote.category,
        campaignNote.title,
        campaignNote.content,
        campaignNote.timestamp,
        JSON.stringify(campaignNote.metadata),
      )
      .run();

    // Log the campaign note creation
    await logAction(c.env, {
      sessionId: input.sessionId,
      kind: 'journal',
      payload: {
        action: 'create_campaign_note',
        noteId,
        category: input.category,
      },
      by: 'system',
      autoGenerated: false,
    });

    return c.json({
      success: true,
      data: campaignNote,
      serverTs: now,
    });
  } catch (error) {
    console.error('Journal add campaign note error:', error);
    if (error instanceof ZodError) {
      return c.json(
        {
          success: false,
          error: JSON.stringify(error.issues),
        },
        400,
      );
    }
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      500,
    );
  }
}

export async function journalGetCampaignNotesHandler(c: any) {
  try {
    const sessionId = c.req.param('sessionId');
    const category = c.req.query('category');
    const limit = parseInt(c.req.query('limit') || '50');
    const offset = parseInt(c.req.query('offset') || '0');

    if (!sessionId) {
      return c.json(
        {
          success: false,
          error: 'sessionId parameter required',
        },
        400,
      );
    }

    let query = 'SELECT * FROM campaign_notes WHERE sessionId = ?';
    const params: any[] = [sessionId];

    if (category) {
      query += ' AND category = ?';
      params.push(category);
    }

    query += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';
    params.push(limit, offset);

    const result = await c.env.DB.prepare(query)
      .bind(...params)
      .all();

    // Parse JSON fields
    const notes = result.results.map((note: any) => ({
      ...note,
      metadata: JSON.parse(note.metadata || '{}'),
    }));

    return c.json({
      success: true,
      data: notes,
      serverTs: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Journal get campaign notes error:', error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      500,
    );
  }
}

export async function journalSearchHandler(c: any) {
  try {
    const body = await c.req.json();
    const input = JournalSearchRequestSchema.parse(body);

    let query = `
      SELECT 'journal' as type, id, sessionId, entryType as category, title, content, timestamp, actorId, location, tags, metadata
      FROM journal_entries 
      WHERE sessionId = ?
    `;
    const params: any[] = [input.sessionId];

    if (input.entryType) {
      query += ' AND entryType = ?';
      params.push(input.entryType);
    }

    if (input.actorId) {
      query += ' AND actorId = ?';
      params.push(input.actorId);
    }

    if (input.startDate) {
      query += ' AND timestamp >= ?';
      params.push(input.startDate);
    }

    if (input.endDate) {
      query += ' AND timestamp <= ?';
      params.push(input.endDate);
    }

    query += `
      UNION ALL
      SELECT 'campaign' as type, id, sessionId, category, title, content, timestamp, NULL as actorId, NULL as location, NULL as tags, metadata
      FROM campaign_notes 
      WHERE sessionId = ?
    `;
    params.push(input.sessionId);

    if (input.category) {
      query += ' AND category = ?';
      params.push(input.category);
    }

    if (input.startDate) {
      query += ' AND timestamp >= ?';
      params.push(input.startDate);
    }

    if (input.endDate) {
      query += ' AND timestamp <= ?';
      params.push(input.endDate);
    }

    query += ' ORDER BY timestamp DESC';

    const result = await c.env.DB.prepare(query)
      .bind(...params)
      .all();

    // Parse JSON fields and filter by search query if provided
    let results = result.results.map((item: any) => ({
      ...item,
      tags: item.tags ? JSON.parse(item.tags) : null,
      metadata: JSON.parse(item.metadata || '{}'),
    }));

    // Apply text search if query provided
    if (input.query) {
      const searchTerm = input.query.toLowerCase();
      results = results.filter(
        (item: any) =>
          item.title.toLowerCase().includes(searchTerm) ||
          item.content.toLowerCase().includes(searchTerm),
      );
    }

    return c.json({
      success: true,
      data: results,
      serverTs: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Journal search error:', error);
    if (error instanceof ZodError) {
      return c.json(
        {
          success: false,
          error: JSON.stringify(error.issues),
        },
        400,
      );
    }
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      500,
    );
  }
}

export async function journalExportHandler(c: any) {
  try {
    const sessionId = c.req.param('sessionId');
    const format = c.req.query('format') || 'json';

    if (!sessionId) {
      return c.json(
        {
          success: false,
          error: 'sessionId parameter required',
        },
        400,
      );
    }

    // Get all journal entries and campaign notes
    const journalResult = await c.env.DB.prepare(
      'SELECT * FROM journal_entries WHERE sessionId = ? ORDER BY timestamp',
    )
      .bind(sessionId)
      .all();

    const campaignResult = await c.env.DB.prepare(
      'SELECT * FROM campaign_notes WHERE sessionId = ? ORDER BY timestamp',
    )
      .bind(sessionId)
      .all();

    const exportData = {
      sessionId,
      exportedAt: new Date().toISOString(),
      journalEntries: journalResult.results.map((entry: any) => ({
        ...entry,
        tags: JSON.parse(entry.tags || '[]'),
        metadata: JSON.parse(entry.metadata || '{}'),
      })),
      campaignNotes: campaignResult.results.map((note: any) => ({
        ...note,
        metadata: JSON.parse(note.metadata || '{}'),
      })),
    };

    if (format === 'markdown') {
      const markdown = generateMarkdownExport(exportData);
      return new Response(markdown, {
        headers: {
          'content-type': 'text/markdown',
          'content-disposition': `attachment; filename="session-${sessionId}-export.md"`,
        },
      });
    }

    return c.json({
      success: true,
      data: exportData,
      serverTs: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Journal export error:', error);
    return c.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      },
      500,
    );
  }
}

// Helper function to log actions
async function logAction(
  env: Env,
  logData: {
    sessionId: string;
    actorId?: string;
    kind: string;
    payload: any;
    by: string;
    autoGenerated?: boolean;
  },
) {
  const logId = uuidv4();
  const logEntry = {
    id: logId,
    sessionId: logData.sessionId,
    actorId: logData.actorId || null,
    ts: new Date().toISOString(),
    kind: logData.kind,
    payload: logData.payload,
    by: logData.by,
    seed: null,
    hash: null,
    journalEntryId: null,
    autoGenerated: logData.autoGenerated || false,
  };

  await env.DB.prepare(
    `
    INSERT INTO action_logs (id, sessionId, actorId, ts, kind, payload, by, seed, hash, journalEntryId, autoGenerated)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `,
  )
    .bind(
      logEntry.id,
      logEntry.sessionId,
      logEntry.actorId,
      logEntry.ts,
      logEntry.kind,
      JSON.stringify(logEntry.payload),
      logEntry.by,
      logEntry.seed,
      logEntry.hash,
      logEntry.journalEntryId,
      logEntry.autoGenerated ? 1 : 0,
    )
    .run();
}

// Helper function to generate markdown export
function generateMarkdownExport(data: any): string {
  let markdown = `# Session Export: ${data.sessionId}\n\n`;
  markdown += `**Exported:** ${data.exportedAt}\n\n`;

  // Journal Entries
  if (data.journalEntries.length > 0) {
    markdown += `## Journal Entries\n\n`;
    data.journalEntries.forEach((entry: any) => {
      markdown += `### ${entry.title}\n`;
      markdown += `**Type:** ${entry.entryType} | **Date:** ${entry.timestamp}\n`;
      if (entry.location) markdown += `**Location:** ${entry.location}\n`;
      if (entry.tags && entry.tags.length > 0) {
        markdown += `**Tags:** ${entry.tags.join(', ')}\n`;
      }
      markdown += `\n${entry.content}\n\n---\n\n`;
    });
  }

  // Campaign Notes
  if (data.campaignNotes.length > 0) {
    markdown += `## Campaign Notes\n\n`;
    data.campaignNotes.forEach((note: any) => {
      markdown += `### ${note.title}\n`;
      markdown += `**Category:** ${note.category} | **Date:** ${note.timestamp}\n`;
      markdown += `\n${note.content}\n\n---\n\n`;
    });
  }

  return markdown;
}
